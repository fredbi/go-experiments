// Code generated by gen-map-getters; DO NOT EDIT.

package geojson

// NO TEST

import (
	"fmt"

	"github.com/go-openapi/swag"
)

// Properties defines the feature properties with some helper methods.
type Properties map[string]interface{}

// MarshalJSON will marshal the properties into the correct json structure.
func (p Properties) MarshalJSON() ([]byte, error) {
	if p == nil {
		return jsonNil, nil
	}
	return json.Marshal(map[string]interface{}(p))
}

// Clone returns a shallow copy of the properties.
func (p Properties) Clone() Properties {
	n := make(Properties, len(p))
	for k, v := range p {
		n[k] = v
	}

	return n
}

// GetInt guarantees the return of a int (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetInt(key string, def ...int) (int, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(int); valid {
			return i, nil
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return int(f), nil
		}

		return 0, fmt.Errorf("expected int, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return 0, nil
}

// GetIntOK guarantees the return of a int (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetIntOK(key string, def ...int) (int, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(int); valid {
			return i, valid
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return int(f), true
		}

		return 0, false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return 0, false
}

// MustGetInt guarantees the return of a int (with optional default).
// This function useful when you explicitly want a int in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetInt("param1"), f.Properties.MustGetInt("optional_param", 8))
// This function will panic if the value is present but not a int.
func (p Properties) MustGetInt(key string, def ...int) int {
	res, err := p.GetInt(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}

// GetInt8 guarantees the return of a int8 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetInt8(key string, def ...int8) (int8, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(int8); valid {
			return i, nil
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return int8(f), nil
		}

		return 0, fmt.Errorf("expected int8, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return 0, nil
}

// GetInt8OK guarantees the return of a int8 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetInt8OK(key string, def ...int8) (int8, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(int8); valid {
			return i, valid
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return int8(f), true
		}

		return 0, false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return 0, false
}

// MustGetInt8 guarantees the return of a int8 (with optional default).
// This function useful when you explicitly want a int8 in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetInt8("param1"), f.Properties.MustGetInt8("optional_param", 18))
// This function will panic if the value is present but not a int8.
func (p Properties) MustGetInt8(key string, def ...int8) int8 {
	res, err := p.GetInt8(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}

// GetInt16 guarantees the return of a int16 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetInt16(key string, def ...int16) (int16, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(int16); valid {
			return i, nil
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return int16(f), nil
		}

		return 0, fmt.Errorf("expected int16, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return 0, nil
}

// GetInt16OK guarantees the return of a int16 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetInt16OK(key string, def ...int16) (int16, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(int16); valid {
			return i, valid
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return int16(f), true
		}

		return 0, false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return 0, false
}

// MustGetInt16 guarantees the return of a int16 (with optional default).
// This function useful when you explicitly want a int16 in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetInt16("param1"), f.Properties.MustGetInt16("optional_param", 4))
// This function will panic if the value is present but not a int16.
func (p Properties) MustGetInt16(key string, def ...int16) int16 {
	res, err := p.GetInt16(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}

// GetInt32 guarantees the return of a int32 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetInt32(key string, def ...int32) (int32, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(int32); valid {
			return i, nil
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return int32(f), nil
		}

		return 0, fmt.Errorf("expected int32, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return 0, nil
}

// GetInt32OK guarantees the return of a int32 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetInt32OK(key string, def ...int32) (int32, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(int32); valid {
			return i, valid
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return int32(f), true
		}

		return 0, false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return 0, false
}

// MustGetInt32 guarantees the return of a int32 (with optional default).
// This function useful when you explicitly want a int32 in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetInt32("param1"), f.Properties.MustGetInt32("optional_param", 348))
// This function will panic if the value is present but not a int32.
func (p Properties) MustGetInt32(key string, def ...int32) int32 {
	res, err := p.GetInt32(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}

// GetInt64 guarantees the return of a int64 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetInt64(key string, def ...int64) (int64, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(int64); valid {
			return i, nil
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return int64(f), nil
		}

		return 0, fmt.Errorf("expected int64, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return 0, nil
}

// GetInt64OK guarantees the return of a int64 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetInt64OK(key string, def ...int64) (int64, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(int64); valid {
			return i, valid
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return int64(f), true
		}

		return 0, false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return 0, false
}

// MustGetInt64 guarantees the return of a int64 (with optional default).
// This function useful when you explicitly want a int64 in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetInt64("param1"), f.Properties.MustGetInt64("optional_param", 82))
// This function will panic if the value is present but not a int64.
func (p Properties) MustGetInt64(key string, def ...int64) int64 {
	res, err := p.GetInt64(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}

// GetUint guarantees the return of a uint (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetUint(key string, def ...uint) (uint, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(uint); valid {
			return i, nil
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return uint(f), nil
		}

		return 0, fmt.Errorf("expected uint, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return 0, nil
}

// GetUintOK guarantees the return of a uint (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetUintOK(key string, def ...uint) (uint, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(uint); valid {
			return i, valid
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return uint(f), true
		}

		return 0, false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return 0, false
}

// MustGetUint guarantees the return of a uint (with optional default).
// This function useful when you explicitly want a uint in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetUint("param1"), f.Properties.MustGetUint("optional_param", 54))
// This function will panic if the value is present but not a uint.
func (p Properties) MustGetUint(key string, def ...uint) uint {
	res, err := p.GetUint(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}

// GetUint8 guarantees the return of a uint8 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetUint8(key string, def ...uint8) (uint8, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(uint8); valid {
			return i, nil
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return uint8(f), nil
		}

		return 0, fmt.Errorf("expected uint8, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return 0, nil
}

// GetUint8OK guarantees the return of a uint8 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetUint8OK(key string, def ...uint8) (uint8, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(uint8); valid {
			return i, valid
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return uint8(f), true
		}

		return 0, false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return 0, false
}

// MustGetUint8 guarantees the return of a uint8 (with optional default).
// This function useful when you explicitly want a uint8 in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetUint8("param1"), f.Properties.MustGetUint8("optional_param", 193))
// This function will panic if the value is present but not a uint8.
func (p Properties) MustGetUint8(key string, def ...uint8) uint8 {
	res, err := p.GetUint8(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}

// GetUint16 guarantees the return of a uint16 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetUint16(key string, def ...uint16) (uint16, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(uint16); valid {
			return i, nil
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return uint16(f), nil
		}

		return 0, fmt.Errorf("expected uint16, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return 0, nil
}

// GetUint16OK guarantees the return of a uint16 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetUint16OK(key string, def ...uint16) (uint16, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(uint16); valid {
			return i, valid
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return uint16(f), true
		}

		return 0, false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return 0, false
}

// MustGetUint16 guarantees the return of a uint16 (with optional default).
// This function useful when you explicitly want a uint16 in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetUint16("param1"), f.Properties.MustGetUint16("optional_param", 4948))
// This function will panic if the value is present but not a uint16.
func (p Properties) MustGetUint16(key string, def ...uint16) uint16 {
	res, err := p.GetUint16(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}

// GetUint32 guarantees the return of a uint32 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetUint32(key string, def ...uint32) (uint32, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(uint32); valid {
			return i, nil
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return uint32(f), nil
		}

		return 0, fmt.Errorf("expected uint32, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return 0, nil
}

// GetUint32OK guarantees the return of a uint32 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetUint32OK(key string, def ...uint32) (uint32, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(uint32); valid {
			return i, valid
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return uint32(f), true
		}

		return 0, false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return 0, false
}

// MustGetUint32 guarantees the return of a uint32 (with optional default).
// This function useful when you explicitly want a uint32 in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetUint32("param1"), f.Properties.MustGetUint32("optional_param", 188))
// This function will panic if the value is present but not a uint32.
func (p Properties) MustGetUint32(key string, def ...uint32) uint32 {
	res, err := p.GetUint32(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}

// GetUint64 guarantees the return of a uint64 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetUint64(key string, def ...uint64) (uint64, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(uint64); valid {
			return i, nil
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return uint64(f), nil
		}

		return 0, fmt.Errorf("expected uint64, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return 0, nil
}

// GetUint64OK guarantees the return of a uint64 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetUint64OK(key string, def ...uint64) (uint64, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(uint64); valid {
			return i, valid
		}
		if f, valid := v.(float64); valid && swag.IsFloat64AJSONInteger(f) {
			return uint64(f), true
		}

		return 0, false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return 0, false
}

// MustGetUint64 guarantees the return of a uint64 (with optional default).
// This function useful when you explicitly want a uint64 in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetUint64("param1"), f.Properties.MustGetUint64("optional_param", 1933))
// This function will panic if the value is present but not a uint64.
func (p Properties) MustGetUint64(key string, def ...uint64) uint64 {
	res, err := p.GetUint64(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}

// GetBool guarantees the return of a bool (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetBool(key string, def ...bool) (bool, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(bool); valid {
			return i, nil
		}
		return false, fmt.Errorf("expected bool, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return false, nil
}

// GetBoolOK guarantees the return of a bool (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetBoolOK(key string, def ...bool) (bool, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(bool); valid {
			return i, valid
		}
		return false, false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return false, false
}

// MustGetBool guarantees the return of a bool (with optional default).
// This function useful when you explicitly want a bool in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetBool("param1"), f.Properties.MustGetBool("optional_param", false))
// This function will panic if the value is present but not a bool.
func (p Properties) MustGetBool(key string, def ...bool) bool {
	res, err := p.GetBool(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}

// GetString guarantees the return of a string (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetString(key string, def ...string) (string, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(string); valid {
			return i, nil
		}
		return "", fmt.Errorf("expected string, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return "", nil
}

// GetStringOK guarantees the return of a string (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetStringOK(key string, def ...string) (string, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(string); valid {
			return i, valid
		}
		return "", false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return "", false
}

// MustGetString guarantees the return of a string (with optional default).
// This function useful when you explicitly want a string in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetString("param1"), f.Properties.MustGetString("optional_param", "some string"))
// This function will panic if the value is present but not a string.
func (p Properties) MustGetString(key string, def ...string) string {
	res, err := p.GetString(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}

// GetFloat32 guarantees the return of a float32 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetFloat32(key string, def ...float32) (float32, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(float32); valid {
			return i, nil
		}
		return 0, fmt.Errorf("expected float32, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return 0, nil
}

// GetFloat32OK guarantees the return of a float32 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetFloat32OK(key string, def ...float32) (float32, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(float32); valid {
			return i, valid
		}
		return 0, false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return 0, false
}

// MustGetFloat32 guarantees the return of a float32 (with optional default).
// This function useful when you explicitly want a float32 in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetFloat32("param1"), f.Properties.MustGetFloat32("optional_param", 37.3))
// This function will panic if the value is present but not a float32.
func (p Properties) MustGetFloat32(key string, def ...float32) float32 {
	res, err := p.GetFloat32(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}

// GetFloat64 guarantees the return of a float64 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetFloat64(key string, def ...float64) (float64, error) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(float64); valid {
			return i, nil
		}
		return 0, fmt.Errorf("expected float64, but got %T: %v", v, v)
	}
	if len(def) > 0 {
		return def[0], nil
	}
	return 0, nil
}

// GetFloat64OK guarantees the return of a float64 (with optional default).
// This getter will return an error when there was an invalid type at that key, but
// will otherwise return a default value, or the zero value if the value was not present in the map
func (p Properties) GetFloat64OK(key string, def ...float64) (float64, bool) {
	v, ok := p[key]
	if ok {
		if i, valid := v.(float64); valid {
			return i, valid
		}
		return 0, false
	}
	if len(def) > 0 {
		return def[0], false
	}
	return 0, false
}

// MustGetFloat64 guarantees the return of a float64 (with optional default).
// This function useful when you explicitly want a float64 in a single
// value return context, for example:
//     myFunc(f.Properties.MustGetFloat64("param1"), f.Properties.MustGetFloat64("optional_param", 27.43324))
// This function will panic if the value is present but not a float64.
func (p Properties) MustGetFloat64(key string, def ...float64) float64 {
	res, err := p.GetFloat64(key, def...)
	if err != nil {
		panic(err)
	}
	return res
}
